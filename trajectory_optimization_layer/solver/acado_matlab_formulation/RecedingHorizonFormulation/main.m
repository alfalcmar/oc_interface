%% Main script

clear all
close all
clc

% It's necessary to include the paths of ACADO
run("addpaths.m");

% Initialize the parameters necessary for the simulation
run("param.m");

% Initially, sim_time = 0
sim_time = 0;

% Initialize the variables where the data is going to be kept
STATES      = zeros (steps*(user_points-1) + 1, 8);
CONTROLS    = zeros (steps*(user_points-1) + 1, 5);
STATES_RH   = zeros (steps*(user_points-1) + 1, 8);
CONTROLS_RH = zeros (steps*(user_points-1) + 1, 5);

% Assuming that: 
%       - When it reaches a point, its acceleration will be 0 (not
%       necessarily its velocity)
%
%       - The path from the receding horizon is going to be get from the
%       whole path (including the whole points inserted by the command
%       window)
%      

% ------------ Main loop ------------ 
for i = 1 : (user_points - 1)
    
    % Let's get the initial velocity and acceleration (point to point)
    v_initial = [STATES(steps*(i-1) + 1, 5),    STATES(steps*(i-1) + 1, 6),     STATES(steps*(i-1) + 1, 7)];
    a_initial = [CONTROLS(steps*(i-1) + 1, 2),  CONTROLS(steps*(i-1) + 1, 3),   CONTROLS(steps*(i-1) + 1, 4)];
    
    % To know the path point to point (without receding horizon)
    if i == 1
        points(i,3) = z_start_drone;
    else
        points(i,3) = STATES(steps*(i-1) + 1, 4);
    end
    
    out = formulation(points(i,:), points(i+1,:), sim_time, (sim_time + time_interval), steps, px_windmill, py_windmill, r_windmill, v_initial, a_initial, z_windmill_inspect);
    
    % Refresh the sim_time
    sim_time = sim_time + time_interval;
    
    % Save the states (position and velocity) and the controls
    % (acceleration)
    STATES  ((steps*(i-1) + 1) : steps*i + 1, :) = out.STATES;
    CONTROLS((steps*(i-1) + 1) : steps*i + 1, :) = out.CONTROLS;
    
end
% ------------ End of main loop ------------


%%%%%%%%%%%%%%%%% RECEDING HORIZON %%%%%%%%%%%%%%%%%

% Reinitialize sim_time:
sim_time = 0;


% Initialize
steps_rec_hor2  = steps_rec_hor;
steps_left      = total_steps;

% ------------ Simulating the receding horizon loop ------------
for i = 1 : ceil(total_steps/steps_rec_hor2)
    
%     steps_left              = total_steps - i*steps_rec_hor2;
    
    if steps_left < steps_rec_hor2
        steps_rec_hor = steps_left - 1;
    else
        steps_left              = total_steps - i*steps_rec_hor2;
    end
        
    % If it's the first time running the simulation, use out (the point
    % to point states). If not, use the states generated by the
    % receding_horizon
        
    E = exist('out_RH','var');  % To make sure it doesn't run more than
    % once (in case we operate with a inner loop)
    
    
    if (i == 1 && E == 0)       % If it is the first time simulating:
            
        % Get the initial and final position, velocity and acceleration (receding horizon)
        p_initial = [STATES(steps_rec_hor2*(i-1) + 1, 2),    STATES(steps_rec_hor2*(i-1) + 1, 3),     STATES(steps_rec_hor2*(i-1) + 1, 4)];
        v_initial = [STATES(steps_rec_hor2*(i-1) + 1, 5),    STATES(steps_rec_hor2*(i-1) + 1, 6),     STATES(steps_rec_hor2*(i-1) + 1, 7)];
        a_initial = [CONTROLS(steps_rec_hor2*(i-1) + 1, 2),  CONTROLS(steps_rec_hor2*(i-1) + 1, 3),   CONTROLS(steps_rec_hor2*(i-1) + 1, 4)];
        
        p_final = [STATES(steps_rec_hor2*i + 1, 2),    STATES(steps_rec_hor2*i + 1, 3),     STATES(steps_rec_hor2*i + 1, 4)];
        v_final = [STATES(steps_rec_hor2*i + 1, 5),    STATES(steps_rec_hor2*i + 1, 6),     STATES(steps_rec_hor2*i + 1, 7)];
        a_final = [CONTROLS(steps_rec_hor2*i + 1, 2),  CONTROLS(steps_rec_hor2*i + 1, 3),   CONTROLS(steps_rec_hor2*i + 1, 4)];        
        
    else if (i > 1)             % If it has been simulated more than once:
            
            % Get the initial and final position, velocity and acceleration (receding horizon)
            p_initial = [STATES_RH(steps_rec_hor2*(i-1) + 1, 2),    STATES_RH(steps_rec_hor2*(i-1) + 1, 3),     STATES_RH(steps_rec_hor2*(i-1) + 1, 4)];
            v_initial = [STATES_RH(steps_rec_hor2*(i-1) + 1, 5),    STATES_RH(steps_rec_hor2*(i-1) + 1, 6),     STATES_RH(steps_rec_hor2*(i-1) + 1, 7)];
            a_initial = [CONTROLS_RH(steps_rec_hor2*(i-1) + 1, 2),  CONTROLS_RH(steps_rec_hor2*(i-1) + 1, 3),   CONTROLS_RH(steps_rec_hor2*(i-1) + 1, 4)];
        
            p_final = [STATES((steps_rec_hor2*(i-1) + steps_rec_hor + 1), 2),    STATES((steps_rec_hor2*(i-1) + steps_rec_hor + 1), 3),     STATES((steps_rec_hor2*(i-1) + steps_rec_hor + 1), 4)];
            v_final = [STATES((steps_rec_hor2*(i-1) + steps_rec_hor + 1), 5),    STATES((steps_rec_hor2*(i-1) + steps_rec_hor + 1), 6),     STATES((steps_rec_hor2*(i-1) + steps_rec_hor + 1), 7)];
            a_final = [CONTROLS((steps_rec_hor2*(i-1) + steps_rec_hor + 1), 2),  CONTROLS((steps_rec_hor2*(i-1) + steps_rec_hor + 1), 3),   CONTROLS((steps_rec_hor2*(i-1) + steps_rec_hor + 1), 4)];
            
            
        
        end
    end
    
    out_RH = formulation_RH(p_initial, p_final, sim_time, (sim_time + step2step_time*steps_rec_hor), steps_rec_hor, px_windmill, py_windmill, r_windmill, v_initial, a_initial, a_final, z_windmill_inspect);
    
    % Refresh the sim_time
    sim_time = sim_time + step2step_time*steps_rec_hor2;
        
        
    
    % Save the states (position and velocity) and the controls
    % (acceleration)
    STATES_RH   ((steps_rec_hor2*(i-1) + 1) : (steps_rec_hor2*(i-1) + steps_rec_hor + 1), :) = out_RH.STATES;
    CONTROLS_RH ((steps_rec_hor2*(i-1) + 1) : (steps_rec_hor2*(i-1) + steps_rec_hor + 1), :) = out_RH.CONTROLS;

end
% ------------ End of receding horizon loop ------------ 


% Plot the results
draw3;